# -*- mode: org -*-
* More imperative approach

Consider a state monad, whose state consists of:
- a =Map= from =Name= to =Name=
  (used to rename variables)
- a =Map= from =AbstractValue= to =Name=
  (used to name structs)
- a =Map= from =(AbstractValue, AbstractValue)= to =Name=
  (used to name applications)
- a =Map= from =AbstractValue= to =Name=
  (used to name struct constructors)
- a =Map= from =AbstractValue= to =Name=
  (used to name thunks that need to be forced)
- a =Map= from =AbstractValue= to C types
- a counter used to produce unique names

Whenever we need a name for something, e.g., for a struct, we first
look it up in the corresponding lookup table and return it if it is
there, otherwise generate a new name, increment the counter, and
return the name.

So, our state is
#+BEGIN_SRC haskell
data Table
    = Table { nameVar :: Map Name Name
            , nameStr :: Map AbstractValue Name
            , nameCon :: Map AbstractValue Name
            , nameThk :: Map AbstractValue Name
            , nameApp :: Map (AbstractValue, AbstractValue) Name
            , counter :: Int
            }
#+END_SRC

and our code generator monad is
#+BEGIN_SRC haskell
type CG = State Table

getNameVar :: Name -> CG Name
getNameVar x = do table <- get
                  case (Map.lookup x (nameVar table)) of
                    Just y  -> return y
                    Nothing -> let i = counter table
                                   y = "#:var-" ++ show i
                               in do put table { nameVar = Map.insert x y (nameVar table), counter = succ i }
                                     return y

getNameStr :: AbstractValue -> CG Name
getNameStr v = do table <- get
                  case (Map.lookup x (nameStr table)) of
                    Just n  -> return n
                    Nothing -> let i = counter table
                                   n = "#:str-" ++ show i
                               in do put table { nameStr = Map.insert v n (nameStr table), counter = succ i }
#+END_SRC
and so on (Template Haskell? Lenses?).

Then the type of, say, genCExpr would be
#+BEGIN_SRC haskell
genCExpr :: AbstractAnalysis
         -> AbstractEnvironment
         -> [Name]
         -> CoreExpr
         -> CG CExpr
genCExpr a env fvs (Var x)
    | x `elem` fvs
    = CSlotAccess (CVar "c") <$> getNameStr x
    | otherwise
    = CVar <$> getNameStr x
genCExpr a env fvs e@(Lam _ _)
    = do name <- nameCon $ Analysis.lookup e env a
         args <- sequence [ CVar <$> getNameVar x
                          | x <- Environment.domain $ Environment.restrict (freeVariables e) env
                          ]
         return $ CFunCall name args
genCExpr a env fvs (App e1 e2)
    = do name <- getNameApp v1 v2
         args <- sequence [ genCExpr a env fvs e
                          | (e, v) <- [(e1, v1), (e2, v2)]
                          ]
         return $ CFunCall name args
    where
      v1 = Analysis.lookup e1 env a
      v2 = Analysis.lookup e2 env a
#+END_SRC
etc.

The advantage is that we don't have to precompute and thread through
the lookup tables: they are carried around and computed on demand.
The code does not seem to become unwieldy, too.  The lookup need not
be total functions: if there is no name for a thing, create it!  So,
it is also safer.

Furthermore, we can wrap this state monad around a writer monad that
is used to collect code that we generate in the process of compiling
the program.  For example, instead of enumerating all thunks in and
generating force functions for each of them in advance, we can
generate these functions whenever we have to force a thunk (i.e., in
the implementation of the IF-PROCEDURE).

* Forcing thunks

Because of the constant conversion, a thunk cannot be forced in the
usual way, i.e., by applying it to the empty list (because there is no
such thing as the empty list at the level of expressions).  There are
several ways to work around this problem.  For example, we could apply
a thunk to a variable that is bound to the empty list.  However, there
may be no such variable in the environment of the thunk, and
introducing it is somewhat tricky.  For example, we could generate a
fresh variable and bind it to the empty list every time we force a
thunk.  However, I suspect that this will screw up the flow analysis.
We could try to enforce the condition that every environment contains
a distinguished variable =#:nil= bound to the empty list, and that the
environment of any closure contains only free variables of the closure
and =#:nil=.  This might actually work.  Or we could observe that
forcing a thunk =(\dummy -> e, env)= is equivalent to evaluating the
body =e= of the thunk in the environment =env= of the thunk.  I have
chosen the latter approach for both the concrete and abstract
evaluator, however it seems to present problems in the code generator.

Changing the enumeration of thunks helps.  Indeed, we don't have to
(and can't) compile /all/ thunks, we only have to consider those being
actually forced (refined) during the flow analysis.  Thus we filter
out the thunks for which =refineThunk= yields bottom.  This seems to
fix the problem with non-matching patterns in =genCExpr=.

Hm.  There are closures that look like thunks and for which
=refineThunk= produces non-bottom, but they are not actually thunks
passed to =IF-PROCEDURE=.  There is a better way to enumerate thunks:
just take the keys of the =thkName= table after compiling all the
primitives!  This seems to produce correct results, but is ugly as
hell.

I changed the way thunks are forced throughout the program.  A thunk
is forced by applying it to the empty list.  In the abstract evaluator
there are two functions =refineThunk= and =expandThunk= that just call
=refineApply= and =expandApply= resp. with the thunk and
=AbstractScalar Nil=.  This way forcing of thunks is a particular case
of the closure application and need not be treated specially by the
code generator (in particular, we don't need =thkName= table and the
problem of thunks enumeration disappears).

* Topological sorting of structs

Instead of sorting the struct declarations topologically, we do the
following trick.  We add slots to =CStruct= and =CStructDecl= for
storing the struct's index, a unique number assigned to the struct at
the moment of its creation.  Furthermore, the function =typeOf=
ensures that this index is assigned to a struct /after/ assigning
indexes to the struct's members.  Then sorting the struct declarations
by their indexes produces the same result as topological sort.
* Inlining
  Some inlining could be performed, but I haven't thoroughly thought
  about that and about difficulties this may face.  For example, C
  does not have an analog of LET expression, so the only way to get
  sharing is by stacking a sequence of statements (assign the result
  of an operation, to a variable, destructure it appropriately, then
  perform some operations on its parts).  Sharing is necessary, e.g.,
  when implementing IF-PROCEDURE: it is essentially turned into a
  ternary conditional x.a ? x.d.a : x.d.d, and if we substitute an
  expression for x, then this expression is going to be computed
  twice: once for the predicate and one for the respective branch.
  Replacing expressions with lists of statements is apparently
  possible, but then the code generator would be much more complex.

  Thus primitives are treated in the same way as closures: for every
  primitive application there is a function that is called with the
  appropriate arguments that does the application.  The body of this
  function may consist of =return r;= if the result =r= of the
  application is known to the analysis /and/ can be inlined as a C
  literal (i.e., if =r= is a real or boolean).  =car= and =cdr= could
  be inlined too if the results of their applications are known at the
  analysis time, but these results can be non-literal (pairs,
  closures), which need to be built by calling appropriate constructor
  functions.  I am not doing this now, because this would obscure the
  program.
