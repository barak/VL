# -*- mode: org -*-
* More imperative approach

Consider a state monad, whose state consists of:
- a =Map= from =Name= to =Name=
  (used to rename variables)
- a =Map= from =AbstractValue= to =Name=
  (used to name structs)
- a =Map= from =(AbstractValue, AbstractValue)= to =Name=
  (used to name applications)
- a =Map= from =AbstractValue= to =Name=
  (used to name struct constructors)
- a =Map= from =AbstractValue= to =Name=
  (used to name thunks that need to be forced)
- a =Map= from =AbstractValue= to C types
- a counter used to produce unique names

Whenever we need a name for something, e.g., for a struct, we first
look it up in the corresponding lookup table and return it if it is
there, otherwise generate a new name, increment the counter, and
return the name.

So, our state is
#+BEGIN_SRC haskell
data Table
    = Table { nameVar :: Map Name Name
            , nameStr :: Map AbstractValue Name
            , nameCon :: Map AbstractValue Name
            , nameThk :: Map AbstractValue Name
            , nameApp :: Map (AbstractValue, AbstractValue) Name
            , counter :: Int
            }
#+END_SRC

and our code generator monad is
#+BEGIN_SRC haskell
type CG = State Table

getNameVar :: Name -> CG Name
getNameVar x = do table <- get
                  case (Map.lookup x (nameVar table)) of
                    Just y  -> return y
                    Nothing -> let i = counter table
                                   y = "#:var-" ++ show i
                               in do put table { nameVar = Map.insert x y (nameVar table), counter = succ i }
                                     return y

getNameStr :: AbstractValue -> CG Name
getNameStr v = do table <- get
                  case (Map.lookup x (nameStr table)) of
                    Just n  -> return n
                    Nothing -> let i = counter table
                                   n = "#:str-" ++ show i
                               in do put table { nameStr = Map.insert v n (nameStr table), counter = succ i }
#+END_SRC
and so on (Template Haskell? Lenses?).

Then the type of, say, genCExpr would be
#+BEGIN_SRC haskell
genCExpr :: AbstractAnalysis
         -> AbstractEnvironment
         -> [Name]
         -> CoreExpr
         -> CG CExpr
genCExpr a env fvs (Var x)
    | x `elem` fvs
    = CSlotAccess (CVar "c") <$> getNameStr x
    | otherwise
    = CVar <$> getNameStr x
genCExpr a env fvs e@(Lam _ _)
    = do name <- nameCon $ Analysis.lookup e env a
         args <- sequence [ CVar <$> getNameVar x
                          | x <- Environment.domain $ Environment.restrict (freeVariables e) env
                          ]
         return $ CFunCall name args
genCExpr a env fvs (App e1 e2)
    = do name <- getNameApp v1 v2
         args <- sequence [ genCExpr a env fvs e
                          | (e, v) <- [(e1, v1), (e2, v2)]
                          ]
         return $ CFunCall name args
    where
      v1 = Analysis.lookup e1 env a
      v2 = Analysis.lookup e2 env a
#+END_SRC
etc.

The advantage is that we don't have to precompute and thread through
the lookup tables: they are carried around and computed on demand.
The code does not seem to become unwieldy, too.  The lookup need not
be total functions: if there is no name for a thing, create it!  So,
it is also safer.

Furthermore, we can wrap this state monad around a writer monad that
is used to collect code that we generate in the process of compiling
the program.  For example, instead of enumerating all thunks in and
generating force functions for each of them in advance, we can
generate these functions whenever we have to force a thunk (i.e., in
the implementation of the IF-PROCEDURE).

* Forcing thunks

Because of the constant conversion, a thunk cannot be forced in the
usual way, i.e., by applying it to the empty list (because there is no
such thing as the empty list at the level of expressions).  There are
several ways to work around this problem.  For example, we could apply
a thunk to a variable that is bound to the empty list.  However, there
may be no such variable in the environment of the thunk, and
introducing it is somewhat tricky.  For example, we could generate a
fresh variable and bind it to the empty list every time we force a
thunk.  However, I suspect that this will screw up the flow analysis.
We could try to enforce the condition that every environment contains
a distinguished variable =#:nil= bound to the empty list, and that the
environment of any closure contains only free variables of the closure
and =#:nil=.  This might actually work.  Or we could observe that
forcing a thunk =(\dummy -> e, env)= is equivalent to evaluating the
body =e= of the thunk in the environment =env= of the thunk.  I have
chosen the latter approach for both the concrete and abstract
evaluator, however it seems to present problems in the code generator.

Changing the enumeration of thunks helps.  Indeed, we don't have to
(and can't) compile /all/ thunks, we only have to consider those being
actually forced (refined) during the flow analysis.  Thus we filter
out the thunks for which 'refineThunk' yields bottom.  This seems to
fix the problem with non-matching patterns in 'genCExpr'.
